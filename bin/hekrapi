#!/usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK
import argparse
import asyncio
import logging
from cmd import Cmd
from collections.abc import Mapping
from typing import Optional, Sequence, Dict, TYPE_CHECKING, IO, TypeVar, Any, Mapping as MappingType, List, Set, \
    Type

from hekrapi.enums import FrameType
from hekrapi.device import Device
from hekrapi.exceptions import HekrAPIException
from hekrapi.protocol import Protocol

if TYPE_CHECKING:
    from hekrapi.account import Account

class HekrAPIPrompt(Cmd):
    pass

HekrAPICLIParser = TypeVar('HekrAPICLIParser')

DEFAULT_DESCRIPTION = 'No description provided'


class AddArgToCommandCalls(argparse.Action):
    def __call__(self, parser, namespace: argparse.Namespace, value, *args, **kwargs):
        current_dict: Optional[Dict[str, Any]] = getattr(namespace, 'arguments', None)

        if current_dict is None:
            setattr(namespace, 'arguments', {self.dest: value})
        else:
            current_dict[self.dest] = value


STR_BOOLEAN_TRUE = ['on', 'true', 'enable', '1', 'start']
STR_BOOLEAN_FALSE = ['off', 'false', 'disable', '0', 'stop']
STR_BOOLEAN_CHOICES = [*STR_BOOLEAN_TRUE, *STR_BOOLEAN_FALSE]


def boolean_converter(value: str) -> bool:
    lower_value = value.lower()
    if lower_value in STR_BOOLEAN_TRUE:
        return True
    if lower_value in STR_BOOLEAN_FALSE:
        return False
    raise ValueError('value does not evaluate to boolean')


def commandline_routine():


def prepare_arguments(protocols: Dict[str, Type['Protocol']]) -> HekrAPICLIParser:
    parser = argparse.ArgumentParser(description='Manipulate supported Hekr devices and accounts')
    parser.add_argument(
        '-d', '--debug',
        help="Print lots of debugging statements",
        action="store_const", dest="loglevel", const=logging.DEBUG,
        default=logging.WARNING,
    )
    parser.add_argument(
        '-v', '--verbose',
        help='Verbose output',
        action='store_const', dest="loglevel", const=logging.INFO,
    )

    # Cloud authentication
    cloud_group = argparse.ArgumentParser(
        description='Utilize local endpoint when executing command / polling device',
        add_help=False
    )
    cloud_group.add_argument(
        '--username', '-u',
        help='Account username',
        action='store',
        required=True
    )
    cloud_group.add_argument(
        '--password', '-p',
        help='Account password',
        action='store',
        required=True
    )

    # Local authentication
    def check_host_port(value: str):
        parts = value.split(':')
        if len(parts) > 2:
            raise ValueError('too many parts')
        port = None
        if len(parts) == 2:
            if parts[1].isnumeric():
                port = int(parts[1])
                if port < 1 or port > 65535:
                    raise ValueError('port value must be inclusively between 1 and 65535')
            else:
                raise ValueError('port must be a number')
        return parts[0], port

    local_group = argparse.ArgumentParser(
        description='Utilize local endpoint when executing command / polling device',
        add_help=False
    )
    local_group.add_argument(
        'device_id',
        help='Device ID',
        action='store',
        metavar='<device ID>'
    )
    local_group.add_argument(
        '--control_key', '-k',
        help='Control key',
        action='store',
        metavar='<control key>',
        required=False
    )
    local_group.add_argument(
        '--host', '-H',
        help='Host to connect to (an attempt will be made to determine '
             'the host using internal discovery algorithms)',
        metavar='HOST[:PORT]',
        type=check_host_port,
        required=False,
    )

    # Parser definition
    subparsers = parser.add_subparsers(title='available sub-commands', dest='section')

    # - Commandline section
    subparsers.add_parser('interactive', help='Launch interactive shell to connect to devices')

    # - Device section
    # --- Execute command
    execute = subparsers.add_parser('execute', help='Execute command on target local device', parents=[local_group])

    protocol_commands = execute.add_subparsers(
        title='available protocols',
        dest='protocol_id',
        required=True,
        metavar='PROTOCOL_ID'
    )

    for protocol_id, protocol in protocols.items():
        callable_commands = {
            name: command
            for name, command in protocol.commands_by_name.items()
            if command.frame_type in [FrameType.SEND, ]
        }

        if callable_commands:
            protocol_parser = protocol_commands.add_parser(
                protocol_id,
                help='%s protocol (command count: %d)'
                     % (protocol.protocol_name, len(callable_commands))
            )
            command_subparsers = protocol_parser.add_subparsers(
                title='available commands',
                dest='command',
                required=True
            )
            for name, command in callable_commands.items():
                command_parser = command_subparsers.add_parser(
                    name,
                    help='Command ID %d: %s' % (command.command_id, command.__doc__),
                )
                if command.arguments:
                    for argument in command.arguments:
                        command_parser.add_argument(
                            '--' + argument.name,
                            help=argument.__doc__,
                            required=argument.value_default is None,
                            default=argument.value_default,
                        )

    # ---- Listen command
    listen = subparsers.add_parser('listen', help='Listen to responses on target local device', parents=[local_group])
    listen.add_argument(
        '--protocol', '-p',
        help='Optionally consider responses to be protocol-bound',
        dest='protocol_id',
        required=False,
        metavar='PROTOCOL_ID'
    )
    listen.add_argument(
        '--raw',
        help='Do not process received data',
        dest='raw_responses',
        required=False,
        action='store_true',
        default=False
    )

    # ---- Tests command
    tests = subparsers.add_parser('tests', help='Testing toolbox')
    tests_subparsers = tests.add_subparsers(dest='action', required=True)

    # ------ Socket server
    socket_server = tests_subparsers.add_parser('udp_server', help='UDP Server with logging')
    socket_server.add_argument(
        '--port', '-p',
        help='Listen port (default: %(default)s)',
        default=10001,
        dest='listen_port',
        type=int,
    )
    socket_server.add_argument(
        '--host', '-H',
        help='Listen address (default: %(default)s)',
        default='0.0.0.0',
        dest='listen_host',
    )

    # - Account section
    account = subparsers.add_parser('account', help='Account-related actions')
    _account = account.add_subparsers(title='Available options', dest='action', required=True)

    # --- Check command
    _account.add_parser('check', help='Check authorization with account')

    # --- Devices command
    account_devices = _account.add_parser('devices', help='List devices associated with account')
    account_devices.add_argument('--columns',
                                 help='Column to show in the output\nCan be stacked to show multiple columns',
                                 nargs='+', default=['devTid', 'lanIp', 'ctrlKey'])

    return parser


def _get_dict_key_with_dots(source_dict: MappingType[str, Any], path: str):
    parts = path.split('.')
    current = parts[0]
    value = source_dict.get(current)
    if value is None:
        return None
    if isinstance(value, Mapping):
        if len(parts) > 1:
            return _get_dict_key_with_dots(value, '.'.join(parts[1:]))
        return value
    elif len(parts) > 1:
        return None
    return value


def _create_device(args: argparse.Namespace, protocols: Dict[str, Any]):
    device = Device(device_id=args.device_id)
    protocol_id = getattr(args, 'protocol_id', None)
    if protocol_id is not None:
        device.protocol = protocols[args.protocol_id]
        print(device.protocol)

    control_key = getattr(args, 'control_key', None)
    if control_key is not None:
        device.control_key = args.control_key
    return device


async def _connect_device(args: argparse.Namespace, device: 'Device'):
    host, port = args.host
    local_connector = device.create_local_connector(host=host, port=port)
    device.local_connector.timeout = 2
    await local_connector.open_connection()
    await local_connector.authenticate()
    return local_connector


async def parse_arguments(protocols: Dict[str, Type['Protocol']], descriptions: Optional[Dict[str, str]] = None,
                          args: Optional[Sequence[str]] = None, output_stream: Optional[IO] = None,
                          parser: Optional[HekrAPICLIParser] = None):
    if output_stream is None:
        from sys import stdout
        output_stream = stdout

    if descriptions is None:
        descriptions = dict.fromkeys(protocols.keys(), DEFAULT_DESCRIPTION)

    if parser is None:
        parser = prepare_arguments(protocols)
    args = parser.parse_args()

    logging.basicConfig(stream=output_stream, level=args.loglevel)

    print(args)

    if not (hasattr(args, 'section') and args.section):
        parser.print_help(file=output_stream)

    elif args.section == 'interactive':
        return commandline_routine()

    elif args.section == 'execute':
        device = _create_device(args, protocols)
        try:
            local_connector = await _connect_device(args, device)
            await device.command(
                command=args.command,
                arguments=getattr(args, 'arguments', None)
            )
            try:
                await asyncio.wait_for(local_connector.listener_runner(lambda x: print(x.view())), 30)
            except asyncio.TimeoutError:
                pass

        except HekrAPIException as e:
            print(f'ERROR:Error occurred while performing commands on {device}: {e}', file=output_stream)

    elif args.section == 'listen':
        device = _create_device(args, protocols)
        try:
            local_connector = await _connect_device(args, device)
            await local_connector.listener_runner(lambda x: print(x.view()), raw_responses=args.raw_responses)

        except HekrAPIException as e:
            print(f'ERROR:Error occurred while running listener on {device}: {e}', file=output_stream)

    elif args.section == 'tests':
        if args.action == 'udp_server':
            def udp_server():
                import socket
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

                listen_on = (args.listen_host, args.listen_port)

                print("Listening on udp %s:%s" % listen_on, file=output_stream)

                s.bind(listen_on)
                while True:
                    yield s.recvfrom(128 * 1024)

            for data, addr in udp_server():
                print('from %s received: %s' % (addr, data), file=output_stream)

    # old stuff
    elif args.section == 'protocol':
        if args.action == 'dump':
            if args.protocol_id == 'all':
                # Dump all protocols
                print('{', end='', file=output_stream)
                print_before = ''
                for protocol_id, protocol in protocols.items():
                    print(print_before + '"' + protocol_id + '"', file=output_stream, end=': ')
                    print(protocol.get_definition_serialized(output_format=args.format), file=output_stream, end='')
                    print_before = ','
                print('}')

            else:
                # Dump single protocol
                serialized_definition = protocols[args.protocol_id].get_definition_serialized(output_format=args.format)
                print(serialized_definition, file=output_stream)

        elif args.action == 'list':
            row_format = '{:<20}{:<40}'
            print(row_format.format('[Protocol ID]', '[Description]'), file=output_stream)
            for protocol_id, description in descriptions.items():
                print(row_format.format(protocol_id, description.strip()), file=output_stream)

    elif args.section == 'account':
        try:
            from hekrapi.account import Account
            account = Account(username=args.username, password=args.password)
            await account.authenticate()
            if args.action == 'check':
                print('OK', file=output_stream)

            elif args.action == 'devices':
                from tabulate import tabulate
                from yaml import load, dump
                try:
                    from yaml import CLoader as Loader, CDumper as Dumper
                except ImportError:
                    from yaml import Loader, Dumper

                table_rows = []
                for device_info in await account.get_devices_info():
                    row_values = []
                    for column in args.columns:
                        value = _get_dict_key_with_dots(device_info.device_info_source, column)
                        if value is None:
                            row_values.append('[Not found]')
                        elif isinstance(value, (List, Set, Mapping)):
                            row_values.append(dump(value, Dumper=Dumper, allow_unicode=True))
                        else:
                            row_values.append(str(value))

                    table_rows.append(row_values)

                print(tabulate(table_rows, headers=args.columns), file=output_stream)

        except HekrAPIException as e:
            print(f'ERROR: {e}', file=output_stream)


def main():
    import asyncio
    from hekrapi.protocol import load_all_supported_protocols

    protocols = load_all_supported_protocols()
    parser = prepare_arguments(protocols)

    try:
        # noinspection PyUnresolvedReferences
        from argcomplete import autocomplete
        autocomplete(parser)

    except ImportError:
        pass

    asyncio.run(parse_arguments(protocols, parser=parser), debug=False)


if __name__ == '__main__':
    main()
